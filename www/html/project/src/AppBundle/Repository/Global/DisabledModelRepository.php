<?php

namespace AppBundle\Repository;

/**
 * UserRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class DisabledModelRepository extends \Doctrine\ORM\EntityRepository
{
    
    public function setCacheUtility( $secondLevelCacheUtility ) {
        $this->secondLevelCacheUtility = $secondLevelCacheUtility;
    }
    
    //metodo che recupera tutti i modelli attivi completati o che hanno prodotti per elastica
    public function getAllModelsFosElastica() {
       $repository = $this->getEntityManager()->getRepository('AppBundle:DisabledModel');
       $qb = $repository->createQueryBuilder('m');
       $qb->select('m,e');       
       $qb->join('m.externalTecnicalTemplate', 'e');

       $qb->where('m.isActive = 1 and m.isCompleted = 1 ');            
       return $qb;         
    }
    
    
     /*
     * Query che ritorna tutti i prodotti pi첫 venduti
     */
    public function getBestsellerModels( $limit, $category = false, $subcategory = false, $typology = false, $trademark = false, $affiliate = false , $toArray = false) {
        $where = 'm.isActive = 1';
        
        if( !empty( $subcategory ) )
            $where .= ' AND m.subcategory = '.$subcategory;          
        
        if( !empty( $typology ) )
            $where .= ' AND m.typology = '.$typology;          
        
        if( !empty( $category ) )
            $where .= ' AND m.category = '.$category;  
        
        if( !empty( $trademark ) )
            $where .= ' AND m.trademark = '.$trademark;
//        
        if( !empty( $affiliate ) )
            $where .= ' AND m.affiliation = '.$affiliate;
        
        $sql = 'SELECT m,tr,s,t,c FROM AppBundle:DisabledModel m                          
                left JOIN m.trademark tr                 
                left JOIN m.subcategory s                 
                left JOIN m.typology t                 
                left JOIN m.category c                 
                WHERE '. $where .' 
                    and m.isTop = 1 and m.isCompleted=1 and m.inShowcase=1
            ORDER BY m.id DESC';
        $query = $this->getEntityManager()->createQuery( $sql )->setMaxResults($limit);        
        
        $query->setCacheable( true );
        $query->setCacheRegion( 'my_model_region_result' );
                
        if( !SECOND_LEVEL_CACHE_ENABLED || !$query->isCacheable() ) {
            $query->useQueryCache( true );
            $query->useResultCache(true, BESTSELLER_MODEL_REGION_TTL, 'model_getBestsellerModels_CacheORM'.md5( $sql ) );    
        }        
        
        
        try {   
            if (empty($toArray))
                return $query->getResult();
            else
                $response = $query->getResult(\Doctrine\ORM\AbstractQuery::HYDRATE_ARRAY);
                return json_decode(json_encode( $response ), FALSE);

        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }
    
     
    public function findModelsWithLimit( $limit, $name = false, $isCompleted = false, $category = false, $subcategory = false, $typology = false, $inShowcase = false, $revisioned = false, $date = false, $top = false ) { 
        $limit = explode(',', $limit);
        $firstResult = count($limit) == 1 ? 0 : $limit[0];
        $lastResult = count($limit) == 1 ? $limit[0] : $limit[1];

        $where = 'where 1=1';
        if( !empty( $name ) ) {
            $where .= " and m.name like '%$name%'";
        }
        if( $isCompleted !== false ) {
            $where .= " and m.isCompleted = '$isCompleted' ";
        }
        if( $revisioned !== false ) {
            $where .= " and m.revisioned = '$revisioned' ";
        }
        
        if( !empty( $category ) )
            $where .= " and m.category = $category ";
        
        if( !empty( $subcategory ) )
            $where .= " and m.subcategory = $subcategory ";
        
        if( !empty( $typology ) )
            $where .= " and m.typology = $typology ";
        
        
        if(  $top !== false )
            $where .= " and m.isTop = $top ";
        
        if( $date !== false ) {
            $dateInit = date( 'Y-m-d ', strtotime( str_replace( ' ', '-', $date ) ) ). '00:00:00';
            $where .= " and m.dateImport > '$dateInit' ";
        }
        
        if(  $inShowcase !== false )
            $where .= " and m.inShowcase = $inShowcase ";
        
        $query = $this->getEntityManager()
                ->createQuery(
                'SELECT m  FROM AppBundle:DisabledModel m
                    '.$where.'
                ORDER BY m.id ASC')
                ->setFirstResult($firstResult)
                ->setMaxResults($lastResult);
//        echo $query->getSQL();
        try {            
            return $query->getResult();            
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }
    
    /**
     * Recupera i modelli per un marchio e una sottocategoria
     * @param type $subcategoryId
     * @return type
     */
    public function findCountModelsBySubcategoryTypologyTrademark( $subcategoryId = false, $typologyId = false, $trademarkId, $isCompleted = false  ) {         
        $where = '';
        if( !empty( $subcategoryId ) ) {
            $where .= " and m.subcategory = $subcategoryId";
        }
        if( !empty( $typologyId ) ) {
            $where .= " and m.typology = $typologyId";
        }                       
        if( !empty( $isCompleted ) ) {
            $where .= " and m.isCompleted = 1";
        }                       
        
        $sql = 'SELECT  COUNT(m) as tot  FROM AppBundle:DisabledModel m
                    WHERE m.isActive = 1 AND m.trademark = '.$trademarkId.$where.'  
                ';
        
        
        
        $query = $this->getEntityManager()->createQuery( $sql );        
        $query->setCacheable( true );
        $query->setCacheRegion( 'my_model_region_result' );
//        echo $query->getSQL();        
        if( !SECOND_LEVEL_CACHE_ENABLED || !$query->isCacheable() ) {
            $query->useQueryCache( true );
            $query->useResultCache(true, BESTSELLER_MODEL_REGION_TTL, 'model_findCountModelsBySubcategoryTypologyTrademark_CacheORM'.md5( $sql ) );    
        }                
        
        try {
            return $query->getSingleResult();
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }
    
    /**
     * Recupera i modelli per un marchio e una sottocategoria
     * @param type $subcategoryId
     * @return type
     */
    public function findModelsBySubcategoryTypologyTrademark( $subcategoryId = false, $typologyId = false, $trademarkId, $limit = '0,9', $isCompleted = false  ) {         
        $where = ' ';
        if( !empty( $subcategoryId ) ) {
            $where .= " and m.subcategory = $subcategoryId";
        }
        if( !empty( $typologyId ) ) {
            $where .= " and m.typology = $typologyId"; 
        }        
        if( !empty( $isCompleted ) ) {
            $where .= " and m.isCompleted = 1";
        }   
        $limit = explode(',', $limit);
        $firstResult = count($limit) == 1 ? 0 : $limit[0];
        $lastResult = count($limit) == 1 ? $limit[0] : $limit[1];   
        
        $sql = 'SELECT m  FROM AppBundle:DisabledModel m
                
                    WHERE m.isActive = 1 AND m.trademark = '.$trademarkId.$where.'  
                ORDER BY m.dateImport DESC';
        
        $query = $this->getEntityManager()->createQuery( $sql )->setFirstResult($firstResult)->setMaxResults($lastResult);        
        $query->setCacheable( true );
        $query->setCacheRegion( 'my_model_region_result' );
                
        if( !SECOND_LEVEL_CACHE_ENABLED || !$query->isCacheable() ) {
            $query->useQueryCache( true );
            $query->useResultCache(true, BESTSELLER_MODEL_REGION_TTL, 'model_findModelsBySubcategoryTypologyTrademark_CacheORM'.md5( $sql ) );    
        }                
        
        try {            
            return $query->getResult();            
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }
    
    /**
     * Recupera la distinct dei marchi presenti in una sottcategoria
     * @param type $subcategoryId
     * @return type
     */
    public function findDistinctNameUlrTrademarkModelSubcategoryTypology( $subcategoryId = false, $typologyId = false  ) {         
        $where2 = '1=1 ';
        if( !empty( $subcategoryId ) ) {
            $where2 .= " and m.subcategory = $subcategoryId";
        }
        if( !empty( $typologyId ) ) {
            $where2 .= " and m.typology = $typologyId";
        }
        
        $where = ' and m.isActive = 1 and m.hasProducts > 1';
        
                
        $sql = 'SELECT DISTINCT t.nameUrl FROM AppBundle:DisabledModel m
            JOIN m.trademark t
            where '.$where2.$where.'
        ';
        
        $query = $this->getEntityManager()->createQuery( $sql );        
//        echo $query->getSQL ();
        $query->setCacheable( true );
        $query->setCacheRegion( 'my_model_region_result' );
                
        if( !SECOND_LEVEL_CACHE_ENABLED || !$query->isCacheable() ) {
            $query->useQueryCache( true );
            $query->useResultCache(true, BESTSELLER_MODEL_REGION_TTL, 'model_findDistinctTrademarkModelSubcategoryTypology_CacheORM'.md5( $sql ) );    
        }    
        
        try {            
            return $query->getResult();            
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }
    
    /**
     * Recupera la distinct dei marchi presenti in una sottcategoria
     * @param type $subcategoryId
     * @return type
     */
    public function findDistinctIdNameTrademarkModelSubcategoryTypology( $subcategoryId = false, $typologyId = false  ) {         
        $where = 'where m.isActive = 1 ';
        if( !empty( $subcategoryId ) ) {
            $where .= " and m.subcategory = $subcategoryId";
        }
        if( !empty( $typologyId ) ) {
            $where .= " and m.typology = $typologyId";
        }
        
        $sql = 'SELECT DISTINCT t.id, t.name FROM AppBundle:DisabledModel m
            JOIN m.trademark t
            '.$where.' 
        ';
        
        $query = $this->getEntityManager()->createQuery( $sql );        
        $query->setCacheable( true );
        $query->setCacheRegion( 'my_model_region_result' );
                
        if( !SECOND_LEVEL_CACHE_ENABLED || !$query->isCacheable() ) {
            $query->useQueryCache( true );
            $query->useResultCache(true, BESTSELLER_MODEL_REGION_TTL, 'model_findDistinctIdNameTrademarkModelSubcategoryTypology_CacheORM'.md5( $sql ) );    
        }    
        
        try {            
            return $query->getResult();            
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }
    
    
     /*
     * Query che fa la count degli articoli filtrati 
     */
    public function countModels( $name = false, $isCompleted = false, $category = false, $subcategory = false, $typology = false, $inShowcase = false, $revisioned = false, $date = false, $top = false ) {
        $where = 'where 1=1';
        
        if( !empty( $name ) ) {
            $where .= " AND m.name like '%$name%'";
        }
        
        if( $isCompleted !== false ) {
            $where .= " and m.isCompleted = $isCompleted ";
        }
        if( $revisioned !== false ) {
            $where .= " and m.revisioned = '$revisioned' ";
        }
        
        if( !empty( $category ) )
            $where .= " and m.category = $category ";
        
        if( !empty( $subcategory ) )
            $where .= " and m.subcategory = $subcategory ";
        
        if( !empty( $typology ) )
            $where .= " and m.typology = $typology ";
        
        if(  $inShowcase !== false )
            $where .= " and m.inShowcase = $inShowcase ";
        
        if(  $top !== false )
            $where .= " and m.isTop = $top ";
        
        if( $date !== false ) {
            $dateInit = date( 'Y-m-d ', strtotime( str_replace( ' ', '-', $date ) ) ). '00:00:00';
            $where .= " and m.dateImport > '$dateInit' ";
        }
        
        $sql = 'SELECT COUNT(m) as tot FROM AppBundle:DisabledModel m '.$where;        
        $query = $this->getEntityManager()->createQuery( $sql );
        
        try {
            $result = $query->getSingleResult();                 
            
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
        return $result;
    }
    
         /*
     * Query che ritorna tutti i prodotti pi첫 venduti
     */
    public function findBestDiscountedModels( $top, $isCompleted, $inShowcase, $revisioned, $limit = 50, $name = false, $category = false, $subcategory = false, $typology = false , $date = false ) {
//        $limit = explode(',', $limit);
//        $firstResult = count($limit) == 1 ? 0 : $limit[0];
//        $lastResult = count($limit) == 1 ? $limit[0] : $limit[1];

        $where = '';
        if( !empty( $name ) ) {
            $where .= " and m.name like '%$name%'";
        }
        if( $isCompleted !== false ) {
            $where .= " and m.isCompleted = '$isCompleted' ";
        }
        if( $revisioned !== false ) {
            $where .= " and m.revisioned = '$revisioned' ";
        }
        
        if( !empty( $category ) )
            $where .= " and m.category = $category ";
        
        if( !empty( $subcategory ) )
            $where .= " and m.subcategory = $subcategory ";
        
        if( !empty( $typology ) )
            $where .= " and m.typology = $typology ";
        
        
        if(  $top !== false )
            $where .= " and m.isTop = $top ";
        
        if( $date !== false ) {
            $dateInit = date( 'Y-m-d ', strtotime( str_replace( ' ', '-', $date ) ) ). '00:00:00';
            $where .= " and m.dateImport > '$dateInit' ";
        }
        
        if(  $inShowcase !== false )
            $where .= " and m.inShowcase = $inShowcase ";
        
        $query = $this->getEntityManager()
                ->createQuery(
                        'SELECT m FROM AppBundle:DisabledModel m      
                         WHERE m.price > 0  and ( m.price < m.lastPrice )  '.$where.' ORDER BY m.name ASC')->setMaxResults($limit);
        
        try {   
            return $query->getResult();
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }
    
    /*
     * Query che ritorna tutti i modelli recuperati per lista di id
     */
    public function findModelByIds( $ids ) {
        $query = $this->getEntityManager()
                ->createQuery(
                        'SELECT m FROM AppBundle:DisabledModel m      
                         WHERE  m.id IN (:ids) ')->setParameter('ids', $ids);             
        return $query->getResult();
    }
    
    /*
     * Query che ritorna tutti i modelli recuperati per lista di id
     */
    public function findModelByNameUrls( $urls ) {

        $query = $this->getEntityManager()
                ->createQuery(
                        'SELECT m FROM AppBundle:DisabledModel m      
                         WHERE  m.nameUrl IN (:urls) ORDER BY m.id ASC')->setParameter('urls', $urls);
                         
        return $query->getResult();
    }


     /*
     * Query che ritorna tutti i prodotti pi첫 venduti
     */
    public function getCountModelsList( $top, $category, $subcategory, $typology, $microSection = false, $trademark = false, $affiliate = false, $aPrice = false ) {
        $where = 'm.isActive = 1 and m.isCompleted = 1';
                
        if( !empty( $top ) ) 
            $where .= ' AND m.isTop = '.$top;          
        
        if( !empty( $category ) )
            $where .= ' AND m.category = '.$category;  
        
        if( !empty( $subcategory ) )
            $where .= ' AND m.subcategory = '.$subcategory;  
        
        if( !empty( $typology ) )
            $where .= ' AND m.typology = '.$typology;          
                
        if( !empty( $microSection ) )
            $where .= ' AND m.microSection = '.$microSection;          
        
        if( !empty( $trademark ) )
            $where .= ' AND m.trademark = '.$trademark;
//        
        if( !empty( $affiliate ) )
            $where .= ' AND m.affiliation = '.$affiliate;
                
        if( !empty( $aPrice['gte'] ) )
            $where .= ' AND m.price >= '.$aPrice['gte'];
        
        if( !empty( $aPrice['lte'] ) )
            $where .= ' AND m.price <= '.$aPrice['lte'];
        
        $query = $this->getEntityManager()
                ->createQuery(
                'SELECT COUNT(m) as tot FROM AppBundle:DisabledModel m
                WHERE '. $where.'' );

       try {
            return $query->getSingleResult();
        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }
    
    
     /*
     * Query che ritorna tutti i prodotti pi첫 venduti
     */
    public function getModelsList( $limit, $top, $category, $subcategory, $typology, $microSection = false, $trademark = false, $affiliate = false, $aPrice = array() ) {
        $where = 'm.isActive = 1 and m.isCompleted = 1';
        
        if( !empty( $top ) ) 
            $where .= ' AND m.isTop = '.$top;          
        
        if( !empty( $category ) )
            $where .= ' AND m.category = '.$category;          
        
        if( !empty( $subcategory ) )
            $where .= ' AND m.subcategory = '.$subcategory;  
        
        if( !empty( $typology ) )
            $where .= ' AND m.typology = '.$typology;                  
                
        if( !empty( $microSection ) )
            $where .= ' AND m.microSection = '.$microSection;          
        
        if( !empty( $trademark ) )
            $where .= ' AND m.trademark = '.$trademark;
        
        if( !empty( $affiliate ) )
            $where .= ' AND m.affiliation = '.$affiliate;
        
        if( !empty( $aPrice['gte'] ) )
            $where .= ' AND m.price >= '.$aPrice['gte'];
        
        if( !empty( $aPrice['lte'] ) )
            $where .= ' AND m.price <= '.$aPrice['lte'];
        
        
        $limit = explode(',', $limit);
        $firstResult = count($limit) == 1 ? 0 : $limit[0];
        $lastResult = count($limit) == 1 ? $limit[0] : $limit[1];
        
        $query = $this->getEntityManager()
                ->createQuery(
                        'SELECT m FROM AppBundle:DisabledModel m
                        WHERE '. $where .'  ORDER BY m.dateImport DESC')
                ->setFirstResult($firstResult)
                ->setMaxResults($lastResult);
//        echo $query->getSQL();
//        
        try {   
            if (empty($toArray))
                return $query->getResult();
            else
                $response = $query->getResult(\Doctrine\ORM\AbstractQuery::HYDRATE_ARRAY);
                return json_decode(json_encode( $response ), FALSE);

        } catch (\Doctrine\ORM\NoResultException $e) {
            return null;
        }
    }


    
}


